{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>HitboxRemaster is a stand-alone ModuleScript that provides easy and performant dynamic Hitboxes and static Zones.</p> <p>Why HitboxRemaster?</p> <ul> <li>Easy to use - Clear and concise class API, ready for simple operations in just a few lines.</li> <li>Type-safe - Extensively typed. Safe to use in a strict-typechecking environment.</li> <li>Powerful - Libraries like Trajectory and Metafunctions to enable advanced use-cases.</li> <li>Customizable - Customize the behavior of individual Hitboxes and Zones with properties and methods.</li> <li>Performant - Blazingly-fast to run and use. (Details in (root)/Benchmark)</li> <li>Memory-proof - Automatic garbage-collect operations. Manual garbage-collect can be initiated on every class with simple methods.</li> <li>Replication - Fully usable on both server and client.</li> </ul> <p>If anything is missing or broken, file an issue on github</p> <p>Disclaimer: HitboxRemaster is not thoroughly tested in a production environment yet. Production-stability is not guaranteed, although any issue found will be fixed.</p>"},{"location":"#installation","title":"Installation","text":"<p>Both Studio and VSCode:</p> <p>Copy the code of HitboxRemaster into a ModuleScript, then require the ModuleScript on the Script or LocalScript you want to use it in.</p> <p>roblox-ts:</p> <p>gg</p> <p>Read the Examples page for a quickstart guide. Alternatively, you can read the API page for a more in-depth guide.</p> <p>You are free to use and modify HitboxRemaster, for personal or commercial use, with or without credit (though some credit would be nice &lt;3). However, you cannot claim that you made HitboxRemaster.</p>"},{"location":"api/Hitbox/","title":"Hitbox","text":"<p>The main Hitbox class returned by <code>Module.newHitbox(Fields)</code>.</p>"},{"location":"api/Hitbox/#modulenewhitboxfields-string-any","title":"Module.newHitbox(Fields: {string: any})","text":"<p><pre><code>local hitbox = Module.newHitbox({\n    Attachment = attachment or nil,\n    Shape = (\"Box\" or \"Sphere\") or \"Box\",\n    Position = Vector3 or Vector3.new(0, 0, 0),\n    Debounce = number or 5,\n    Pierce = number or 1,\n    LifeTime = number or 1,\n    Orientation = Vector3 or nil,\n    CopyCFrame = BasePart or nil,\n    Radius = number or 3,\n    Size = Vector3 or Vector3.new(3, 3, 3),\n    FilterType = Enum.RaycastFilterType or Enum.RaycastFilterType.Exclude,\n    FilterDescendantsInstances = {Instance} or {},\n    RespectCanCollide = boolean or false,\n    MaxParts = number or 0\n}) -&gt; Hitbox\n</code></pre> Create a new Hitbox object. Fields are optional.</p>"},{"location":"api/Hitbox/#public","title":"Public","text":""},{"location":"api/Hitbox/#hitboxshapeenum","title":"Hitbox.ShapeEnum","text":"<p><pre><code>Hitbox.ShapeEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.Shape</code>. Includes <code>ShapeEnum.Box</code> and <code>ShapeEnum.Sphere</code>.</p>"},{"location":"api/Hitbox/#hitboxmodeenum","title":"Hitbox.ModeEnum","text":"<p><pre><code>Hitbox.ModeEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.HitboxMode</code>. Includes <code>ModeEnum.None</code>, <code>ModeEnum.Attachment</code>, <code>ModeEnum.Linear</code>, <code>ModeEnum.Bezier</code>, <code>ModeEnum.Orientation</code> and <code>ModeEnum.Copying</code></p>"},{"location":"api/Hitbox/#hitboxstateenum","title":"Hitbox.StateEnum","text":"<p><pre><code>Hitbox.StateEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.StateEnum</code>. Includes <code>StateEnum.Paused</code>, <code>StateEnum.Active</code> and <code>StateEnum.Dead</code>.</p>"},{"location":"api/Hitbox/#hitboxconstructionenum","title":"Hitbox.ConstructionEnum","text":"<p><pre><code>Hitbox.ConstructionEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.ConstructionMode</code>. Includes <code>ConstructionEnum.None</code>, <code>ConstructionEnum.Linear</code> and <code>ConstructionEnum.Bezier</code>.</p>"},{"location":"api/Hitbox/#hitboxbezierenum","title":"Hitbox.BezierEnum","text":"<p><pre><code>Hitbox.BezierEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.BezierMode</code>. Includes <code>BezierEnum.Quadratic</code> and <code>BezierEnum.Cubic</code>.</p>"},{"location":"api/Hitbox/#hitboxserial","title":"Hitbox.Serial","text":"<p><pre><code>Hitbox.Serial -- number\n</code></pre> A readonly number that is the Hitbox's unique serial. WARNING: Do NOT change under any circumstance.</p>"},{"location":"api/Hitbox/#hitboxshape","title":"Hitbox.Shape","text":"<p><pre><code>Hitbox.Shape -- string\n</code></pre> The current shape of the Hitbox. Can be <code>Box</code> or <code>Sphere</code>.</p>"},{"location":"api/Hitbox/#hitboxposition","title":"Hitbox.Position","text":"<p><pre><code>Hitbox.Position -- Vector3\n</code></pre> The current center position of the Hitbox. Note: Any changes will be prevented if the Hitbox is currently using a bezier path.</p>"},{"location":"api/Hitbox/#hitboxpierce","title":"Hitbox.Pierce","text":"<p><pre><code>Hitbox.Pierce -- number\n</code></pre> How many Humanoids can the Hitbox hit in total.</p>"},{"location":"api/Hitbox/#hitboxdebounce","title":"Hitbox.Debounce","text":"<p><pre><code>Hitbox.Debounce -- number\n</code></pre> How many seconds have to pass before the Hitbox can hit the same Humanoid again.</p>"},{"location":"api/Hitbox/#hitboxlifetime","title":"Hitbox.LifeTime","text":"<p><pre><code>Hitbox.LifeTime -- number\n</code></pre> How many seconds the Hitbox has left before it automatically cleans and garbage collects itself. Only counts down while the Hitbox is activated. Note: This property does not countdown if the Hitbox is currently using a bezier path. The Hitbox will clean itself when it reaches the end of the bezier path instead.</p>"},{"location":"api/Hitbox/#hitboxorientation","title":"Hitbox.Orientation","text":"<p><pre><code>Hitbox.Orientation -- Vector3\n</code></pre> The orientation of the Hitbox. Note: CopyCFrame overrides this property.</p>"},{"location":"api/Hitbox/#hitboxcopycframe","title":"Hitbox.CopyCFrame","text":"<p><pre><code>Hitbox.CopyCFrame -- BasePart\n</code></pre> A part which the Hitbox will copy Position, Size and Orientation from. WARNING: Overrides orientation and all constructed paths. Does NOT override <code>Hitbox.Shape</code></p>"},{"location":"api/Hitbox/#hitboxoverlapparams","title":"Hitbox.OverlapParams","text":"<p><pre><code>Hitbox.OverlapParams -- OverlapParams\n</code></pre> The <code>OverlapParams</code> that's used for spatial query.</p>"},{"location":"api/Hitbox/#hitboxactive","title":"Hitbox.Active","text":"<p><pre><code>Hitbox.Active -- boolean\n</code></pre> A readonly boolean that displays whether the Hitbox is currently active or not. Note: You should change this with <code>Hitbox:Activate()</code> and <code>Hitbox:Deactivate()</code> instead.</p>"},{"location":"api/Hitbox/#hitboxradius","title":"Hitbox.Radius","text":"<p><pre><code>Hitbox.Radius -- number\n</code></pre> The radius of the Hitbox. Used if <code>Hitbox.Shape</code> is <code>Sphere</code>. Note: CopyCFrame overrides this property.</p>"},{"location":"api/Hitbox/#hitboxsize","title":"Hitbox.Size","text":"<p><pre><code>Hitbox.Size -- Vector3\n</code></pre> The size of the Hitbox. Used if <code>Hitbox.Shape</code> is <code>Box</code>. Note: CopyCFrame overrides this property.</p>"},{"location":"api/Hitbox/#hitboxtrajectory","title":"Hitbox.Trajectory","text":"<p><pre><code>Hitbox.Trajectory -- Trajectory\n</code></pre> The child Trajectory class of the Hitbox. Used for path construction.</p>"},{"location":"api/Hitbox/#hitboxhit","title":"Hitbox.Hit","text":"<p><pre><code>Hitbox.Hit -- ScriptSignal\nHitbox.Hit:Connect(function(Humanoid, HitPart, HitboxDataBundle)\n    ...\nend)\n</code></pre> The child ScriptSignal class of the Hitbox. It is fired whenever the Hitbox hits a Humanoid that does not have a ForceField, is not on Debounce and is not dead.</p>"},{"location":"api/Hitbox/#hitboxactivate","title":"Hitbox:Activate()","text":"<p><pre><code>Hitbox:Activate()\n</code></pre> Activates the Hitbox. Note: When a new Hitbox is created, it is deactivated by default. You need to activate it after configuration.</p>"},{"location":"api/Hitbox/#hitboxdeactivate","title":"Hitbox:Deactivate()","text":"<p><pre><code>Hitbox:Deactivate()\n</code></pre> Deactivates the Hitbox, pausing all operations.</p>"},{"location":"api/Hitbox/#hitboxaddignoreobject-instance","title":"Hitbox:AddIgnore(object: Instance)","text":"<p><pre><code>local success = Hitbox:AddIgnore(game.Players.Player1.Character) -&gt; boolean\n</code></pre> Add <code>object</code> to FilterDescendentsInstances table of <code>OverlapParams</code>. Returns boolean Success.</p>"},{"location":"api/Hitbox/#hitboxremoveignoreobject-instance","title":"Hitbox:RemoveIgnore(object: Instance)","text":"<p><pre><code>local numOfItemsRemoved = Hitbox:RemoveIgnore(game.Players.Player1.Character) -&gt; number\n</code></pre> Remove <code>object</code> from FilterDescendentsInstances table of <code>OverlapParams</code>. Returns number NumberOfItemsRemoved. **Note: The returned number is 0 on an unsuccessful remove, 1 or more on a successful remove.</p>"},{"location":"api/Hitbox/#hitboxgetvelocity","title":"Hitbox:GetVelocity()","text":"<p><pre><code>local velocity = Hitbox:GetVelocity() -&gt; number\n</code></pre> Returns the Velocity of the Hitbox's constructed path.</p>"},{"location":"api/Hitbox/#hitboxsetvelocity","title":"Hitbox:SetVelocity()","text":"<p><pre><code>Hitbox:SetVelocity(velocity: number)\n</code></pre> Sets the Velocity of the Hitbox's constructed path to <code>velocity</code>.</p>"},{"location":"api/Hitbox/#hitboxchangeattachmentattachment-attachment","title":"Hitbox:ChangeAttachment(attachment: Attachment?)","text":"<p><pre><code>Hitbox:ChangeAttachment(attachment)\n</code></pre> Changes the Hitbox's Attachment to <code>attachment</code>. If <code>attachment</code> is nil, remove Attachment from Hitbox.</p>"},{"location":"api/Hitbox/#hitboxishitboxbackstabpart-basepart-databundle-hitboxdatabundle","title":"Hitbox:IsHitboxBackstab(Part: BasePart, DataBundle: HitboxDataBundle)","text":"<p><pre><code>local isBackstab = Hitbox:IsHitboxBackstab(HitPart, HitboxDataBundle) -&gt; boolean\n</code></pre> Determine if the data described by HitboxDataBundle is a backstab on HitPart. Returns boolean.</p>"},{"location":"api/Hitbox/#hitboxisbackstabpart-basepart-character-model","title":"Hitbox:IsBackstab(Part: BasePart, Character: Model)","text":"<p><pre><code>local isBackstab = Hitbox:IsBackstab(Part, Character) -&gt; boolean\n</code></pre> Determine if <code>Character</code> backstabs <code>Part</code>. Returns boolean.</p>"},{"location":"api/Hitbox/#hitboxgetcurrentserial","title":"Hitbox:GetCurrentSerial()","text":"<p><pre><code>local highestSerial = Hitbox:GetCurrentSerial() -&gt; number\n</code></pre> Get the currently highest serial. Returns number.</p>"},{"location":"api/Hitbox/#hitboxgetconstructionmode","title":"Hitbox:GetConstructionMode()","text":"<p><pre><code>local mode = Hitbox:GetConstructionMode() -&gt; string\n</code></pre> Returns the Hitbox's Trajectory's ConstructionMode.</p>"},{"location":"api/Hitbox/#hitboxgetcurrentmode","title":"Hitbox:GetCurrentMode()","text":"<p><pre><code>local mode = Hitbox:GetCurrentMode() -&gt; string\n</code></pre> Get the current behavior of the Hitbox. See <code>Hitbox.ModeEnum</code>.</p>"},{"location":"api/Hitbox/#hitboxvisualize","title":"Hitbox:Visualize()","text":"<p><pre><code>local part = Hitbox:Visualize() -&gt; BasePart or nil\n</code></pre> Visualizes the Hitbox and returns the visualization part if the Hitbox wasn't already visualizing. WARNING: The visualization only updates once every 5 frames and is UNOPTIMIZED. This should only be used for testing purposes.</p>"},{"location":"api/Hitbox/#hitboxunvisualizedonotwarn-boolean","title":"Hitbox:Unvisualize(doNotWarn: boolean?)","text":"<p><pre><code>Hitbox:Unvisualize()\n</code></pre> Unvisualizes the Hitbox. Throws a warn if <code>doNotWarn</code> isn't <code>true</code> and the Hitbox wasn't visualizing.</p>"},{"location":"api/Hitbox/#hitboxdestroy","title":"Hitbox:Destroy()","text":"<p><pre><code>Hitbox:Destroy()\n</code></pre> Immediately clean and garbage collect Hitbox and all its children. Hitbox should be dereferenced after this operation.</p>"},{"location":"api/Hitbox/#private","title":"Private","text":"<p>Note: Private variables, methods and functions should not be used unless you know what you're doing.</p>"},{"location":"api/Hitbox/#hitbox_attachment","title":"Hitbox._Attachment","text":"<p><pre><code>Hitbox._Attachment -- Attachment or nil\n</code></pre> Internal store for the Hitbox's Attachment, if one exists. Note: You should use <code>Hitbox:ChangeAttachment(attachment)</code> instead.</p>"},{"location":"api/Hitbox/#hitbox_currentframe","title":"Hitbox._CurrentFrame","text":"<p><pre><code>Hitbox._CurrentFrame -- number\n</code></pre> The current frame of the Hitbox in the Hitbox's frame cycle. Note: Not strictly readonly, but it's a good idea to keep this readonly.</p>"},{"location":"api/Hitbox/#hitbox_canwarn","title":"Hitbox._CanWarn","text":"<p><pre><code>Hitbox._CanWarn -- boolean\n</code></pre> An internal variable that acts as throttle to prevent console spam.</p>"},{"location":"api/Hitbox/#hitbox_visual","title":"Hitbox._Visual","text":"<p><pre><code>Hitbox._Visual -- BasePart\n</code></pre> The part used for the Hitbox's visualization. WARNING: STRICTLY readonly. Use <code>Hitbox:Visualize()</code> and <code>Hitbox:Unvisualize()</code> instead.</p>"},{"location":"api/Hitbox/#hitbox_destroying","title":"Hitbox._Destroying","text":"<p><pre><code>Hitbox._Destroying -- boolean\n</code></pre> Whether the Hitbox is being garbage collected currently or not. WARNINNG: Readonly. The Hitbox should be dereferenced if this value is <code>true</code>.</p> <p>The main enum is intended to be completely private. You are not meant to access it.</p>"},{"location":"api/ScriptConnection/","title":"ScriptConnection","text":"<p>A class returned by <code>ScriptSignal:Connect()</code> and <code>ScriptSignal:Once()</code>.</p>"},{"location":"api/ScriptConnection/#public","title":"Public","text":""},{"location":"api/ScriptConnection/#scriptconnectionstateenum","title":"ScriptConnection.StateEnum","text":"<p><pre><code>ScriptConnection.StateEnum -- {string: string}\n</code></pre> A mutable copy of <code>enum.StateEnum</code>. Includes <code>StateEnum.Paused</code>, <code>StateEnum.Active</code> and <code>StateEnum.Dead</code>.</p>"},{"location":"api/ScriptConnection/#scriptconnectiongetidentifier","title":"ScriptConnection:GetIdentifier()","text":"<p><pre><code>local identifier = ScriptConnection:GetIdentifier() -&gt; string\n</code></pre> Return the ScriptConnection's unique identifier as a string.</p>"},{"location":"api/ScriptConnection/#scriptconnectiondisconnect","title":"ScriptConnection:Disconnect()","text":"<p><pre><code>ScriptConnection:Disconnect()\n</code></pre> Disconnect the ScriptConnection, clean the entire object to be garbage collected except for ScriptConnection._State. Set ScriptConnection._State to \"Dead\".</p>"},{"location":"api/ScriptConnection/#private","title":"Private","text":"<p>Note: Private variables, methods and functions should not be used unless you know what you're doing.</p>"},{"location":"api/ScriptConnection/#scriptconnection_connected","title":"ScriptConnection._Connected","text":"<p><pre><code>ScriptConnection._Connected -- boolean\n</code></pre> Whether the ScriptConnection is connected or not.</p>"},{"location":"api/ScriptConnection/#scriptconnection_once","title":"ScriptConnection._Once","text":"<p><pre><code>ScriptConnect._Once -- boolean\n</code></pre> If <code>true</code>, automatically disconnects the ScriptConnection immediately when being fired the next time.</p>"},{"location":"api/ScriptConnection/#scriptconnection_identifier","title":"ScriptConnection._Identifier","text":"<p><pre><code>ScriptConnection._Identifier -- string\n</code></pre> The assigned unique identifier of the ScriptConnection.</p>"},{"location":"api/ScriptConnection/#scriptconnection_state","title":"ScriptConnection._State","text":"<p><pre><code>ScriptConnection._State -- string\n</code></pre> The current state of the ScriptConnection. Can be <code>Active</code>, <code>Paused</code> or <code>Dead</code>. If the state is <code>Dead</code>, the ScriptConnection should not be referenced anymore.</p>"},{"location":"api/ScriptConnection/#scriptconnection_signal","title":"ScriptConnection._Signal","text":"<p><pre><code>ScriptConnection._Signal -- ScriptSignal\n</code></pre> A pointer to the parent ScriptSignal.</p>"},{"location":"api/ScriptConnection/#scriptconnection_function","title":"ScriptConnection._Function","text":"<p><pre><code>ScriptConnection._Function -- function\n</code></pre> The function that will be fired when the ScriptConnection is fired.</p>"},{"location":"api/ScriptConnection/#scriptconnection_fire","title":"ScriptConnection._Fire(...)","text":"<p><pre><code>ScriptConnection._Fire(...)\n</code></pre> An internal function to fire the ScriptConnection. Passes the arguments to the fired function.</p> <p>The main enum is intended to be completely private. You are not meant to access it.</p>"},{"location":"api/ScriptSignal/","title":"ScriptSignal","text":"<p>A member class of Hitbox and Zone. Also returned by <code>Module.newSignal()</code>.</p>"},{"location":"api/ScriptSignal/#public","title":"Public","text":""},{"location":"api/ScriptSignal/#scriptsignalstateenum","title":"ScriptSignal.StateEnum","text":"<p><pre><code>ScriptSignal.StateEnum -- string\n</code></pre> An immutable copy of <code>enum.StateEnum</code>. Includes <code>StateEnum.Paused</code>, <code>StateEnum.Active</code> and <code>StateEnum.Dead</code>.</p>"},{"location":"api/ScriptSignal/#scriptsignalconnectfunc-function-connectimmediately-boolean","title":"ScriptSignal:Connect(func: function, connectImmediately: boolean?)","text":"<p><pre><code>local Connection = ScriptSignal:Connect(function()\n    ...\nend, false) -&gt; ScriptConnection\n</code></pre> Creates a new <code>ScriptConnection</code>. If <code>connectImmediately</code> is <code>true</code> or <code>nil</code>, the ScriptConnection is then immediately connected to the ScriptSignal.</p>"},{"location":"api/ScriptSignal/#scriptsignaloncefunc-function","title":"ScriptSignal:Once(func: function)","text":"<p><pre><code>local Connection = ScriptSignal:Once(function()\n    ...\nend)\n</code></pre> Creates a new connected <code>ScriptConnection</code>. The ScriptConnection will clean and garbage collect itself when it is fired for the first time.</p>"},{"location":"api/ScriptSignal/#scriptsignaldisconnectall","title":"ScriptSignal:DisconnectAll()","text":"<p><pre><code>ScriptSignal:DisconnectAll()\n</code></pre> Disconnect and garbage collect all of ScriptSignal's ScriptConnections.</p>"},{"location":"api/ScriptSignal/#scriptsignaldisconnectoneidentifier-string","title":"ScriptSignal:DisconnectOne(identifier: string)","text":"<p><pre><code>ScriptSignal:DisconnectOne(\"GH4X-K93A-3914-FD3P-MN0O\")\n</code></pre> Disconnect any ScriptConnection connected to ScriptSignal with <code>identifier</code> as its identifier.</p>"},{"location":"api/ScriptSignal/#scriptsignalfire","title":"ScriptSignal:Fire(...)","text":"<p><pre><code>ScriptSignal:Fire(...)\n</code></pre> Fire all of ScriptSignal's ScriptConnections and passes <code>...</code> as arguments.</p>"},{"location":"api/ScriptSignal/#scriptsignalfireoneidentifier-string-args","title":"ScriptSignal:FireOne(identifier: string, args: {...})","text":"<p><pre><code>ScriptSignal:FireOne(\"GH4X-K93A-3914-FD3P-MN0O\", {...})\n</code></pre> Fire any ScriptConnection connected to ScriptSignal with <code>identifier</code> as its identifier. Passes an unpacked version of <code>args</code> as arguments.</p>"},{"location":"api/ScriptSignal/#scriptsignalgetstate","title":"ScriptSignal:GetState()","text":"<p><pre><code>local state = ScriptSignal:GetState() -&gt; string\n</code></pre> Get the current state of the ScriptSignal. WARNING: Calling this method while the ScriptSignal is Dead will throw an error.</p>"},{"location":"api/ScriptSignal/#scriptsignaldestroy","title":"ScriptSignal:Destroy()","text":"<p><pre><code>ScriptSignal:Destroy()\n</code></pre> Immediately clean and garbage collect ScriptSignal and all its children. ScriptSignal should be dereferenced after this operation.</p>"},{"location":"api/ScriptSignal/#private","title":"Private","text":"<p>Note: Private variables, methods and functions should not be used unless you know what you're doing.</p>"},{"location":"api/ScriptSignal/#scriptsignal_state","title":"ScriptSignal._State","text":"<p><pre><code>ScriptSignal._State -- string\n</code></pre> The current state of the ScriptSignal. Can be <code>Active</code>, <code>Paused</code> or <code>Dead</code>. If the state is <code>Dead</code>, the ScriptSignal should not be referenced anymore.</p>"},{"location":"api/ScriptSignal/#scriptsignal_activerunner","title":"ScriptSignal._ActiveRunner","text":"<p><pre><code>ScriptSignal._ActiveRunner -- ConnectionRunner\n</code></pre> The active ConnectionRunner middleware of the ScriptSignal. WARNING: ConnectionRunner is intended to be completely private. You should not perform any operation on it. The main enum is intended to be completely private. You are not meant to access it.</p>"},{"location":"api/Trajectory/","title":"Trajectory","text":"<p>Child class of Hitbox. Used for constructing paths that the Hitbox will traverse automatically.</p>"},{"location":"api/Trajectory/#public","title":"Public","text":""},{"location":"api/Trajectory/#trajectoryconstructionmode","title":"Trajectory.ConstructionMode","text":"<p><pre><code>Trajectory.ConstructionMode -- string\n</code></pre> The current ConstructionMode of the Trajectory. Can be <code>None</code>, <code>Linear</code> or <code>Bezier</code></p>"},{"location":"api/Trajectory/#trajectoryvelocity","title":"Trajectory.Velocity","text":"<p><pre><code>Trajectory.Velocity -- number\n</code></pre> The speed in studs per second in which the Hitbox will traverse the constructed path.</p>"},{"location":"api/Trajectory/#trajectoryconstructconstructionmode-string-fields-string-any","title":"Trajectory:Construct(ConstructionMode: string, Fields: {string: any})","text":"<p><pre><code>Trajectory:Construct(\"Linear\", {\n    DirectionalVector = Vector3.new(0.55, -0.02, 0.4),\n    Velocity = 25\n})\nTrajectory:Construct(\"Bezier\", {\n    BezierPoints = {\n        Start = Vector3.new(),\n        Control1 = Vector3.new(),\n        Control2 = Vector3.new() or nil,\n        End = Vector3.new()\n    },\n    Velocity = 25\n})\nTrajectory:Construct(\"None\")\n</code></pre> Construct a path using <code>ConstructionMode</code> and <code>Fields</code> as seen above. If <code>BezierPoints.Control2</code> is nil, the path will become a quadratic bezier curve. Otherwise, the path will become a cubic bezier curve. <code>DirectionalVector</code> MUST be a normalized. If <code>Velocity</code> is nil, it will use the previous Velocity. If <code>ConstructionMode</code> is <code>None</code>, deconstructs the path instead.</p>"},{"location":"api/Trajectory/#trajectorydeconstruct","title":"Trajectory:Deconstruct()","text":"<p><pre><code>Trajectory:Deconstruct()\n</code></pre> Deconstruct any constructed path and sets <code>Trajectory.ConstructionMode</code> to <code>None</code>.</p>"},{"location":"api/Trajectory/#private","title":"Private","text":"<p>Note: Private variables, methods and functions should not be used unless you know what you're doing.</p>"},{"location":"api/Trajectory/#trajectory_directionalvector","title":"Trajectory._DirectionalVector","text":"<p><pre><code>Trajectory._DirectionVector -- Vector3 or nil\n</code></pre> The stored DirectionalVector from <code>Trajectory:Construct()</code>.</p>"},{"location":"api/Trajectory/#trajectory_length","title":"Trajectory._Length","text":"<p><pre><code>Trajectory._Length -- number\n</code></pre> Stores the approximate length of the path only if the <code>ConstructionMode</code> is <code>Bezier</code>.</p>"},{"location":"api/Trajectory/#trajectory_completion","title":"Trajectory._Completion","text":"<p><pre><code>Trajectory._Completion -- number\n</code></pre> A normalized number which tracks how close the Hitbox is to the end of the path only if the <code>ConstructionMode</code> is <code>Bezier</code>.</p>"},{"location":"api/Trajectory/#trajectory_points","title":"Trajectory._Points","text":"<p><pre><code>Trajectory._Points --[[ {\n                          Start = Vector3.new(),\n                          Control1 = Vector3.new(),\n                          Control2 = Vector3.new() or nil,\n                          End = Vector3.new()\n                        } --]]\n</code></pre> The stored BezierPoints from <code>Trajectory:Construct()</code>.</p>"},{"location":"api/Trajectory/#trajectory_getbeziermode","title":"Trajectory:_GetBezierMode()","text":"<p><pre><code>local mode = Trajectory:_GetBezierMode() -&gt; string\n</code></pre> Returns either <code>Quad</code> or <code>Cubic</code> based on the bezier formula used.</p>"},{"location":"api/Zone/","title":"Zone","text":"<p>Parent class of ZoneComponent, ScriptSignal and Metafunctions. Returned by <code>Module.newZone(Fields)</code>.</p>"},{"location":"api/Zone/#public","title":"Public","text":""},{"location":"api/Zone/#zonecharacterresolutionenum","title":"Zone.CharacterResolutionEnum","text":"<p><pre><code>Zone.CharacterResolutionEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.CharacterResolution</code>. Includes <code>CharacterResolutionEnum.FullBody</code>, <code>CharacterResolutionEnum.Root</code>, <code>CharacterResolutionEnum.Head</code> and <code>CharacterResolutionEnum.OnePart</code>.</p>"},{"location":"api/Zone/#zonequerytypeenum","title":"Zone.QueryTypeEnum","text":"<p><pre><code>Zone.QueryTypeEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.QueryType</code>. Includes <code>QueryTypeEnum.Full</code> and <code>QueryTypeEnum.Bounds</code>.</p>"},{"location":"api/Zone/#zonestateenum","title":"Zone.StateEnum","text":"<p><pre><code>Zone.StateEnum -- {string: string}\n</code></pre> An immutable copy of <code>enum.StateEnum</code>. Includes <code>StateEnum.Paused</code>, <code>StateEnum.Active</code> and <code>StateEnum.Dead</code>.</p>"},{"location":"api/Zone/#zonepartentered","title":"Zone.PartEntered","text":"<p><pre><code>Zone.PartEntered -- ScriptSignal\nlocal connection = Zone.PartEntered:Connect(function(oart)\n    ...\nend)\n</code></pre> A ScriptSignal that fires when a part enters the Zone.</p>"},{"location":"api/Zone/#zonepartleft","title":"Zone.PartLeft","text":"<p><pre><code>Zone.PartLeft -- ScriptSignal\nlocal connection = Zone.PartLeft:Connect(function(part)\n    ...\nend)\n</code></pre> A ScriptSignal that fires when a part leaves the Zone.</p>"},{"location":"api/Zone/#zonecharacterentered","title":"Zone.CharacterEntered","text":"<p><pre><code>Zone.CharacterEntered -- ScriptSignal\nlocal connection = Zone.CharacterEntered:Connect(function(character)\n    ...\nend)\n</code></pre> A ScriptSignal that fires when a character (including players) enter the Zone.</p>"},{"location":"api/Zone/#zonecharacterleft","title":"Zone.CharacterLeft","text":"<p><pre><code>Zone.CharacterLeft -- ScriptSignal\nlocal connection = Zone.CharacterLeft:Connect(function(character)\n    ...\nend)\n</code></pre> A ScriptSignal that fires when a character (including players) leaves the Zone.</p>"},{"location":"api/Zone/#zoneplayerentered","title":"Zone.PlayerEntered","text":"<p><pre><code>Zone.PlayerEntered -- ScriptSignal\nlocal connection = Zone.PlayerEntered:Connect(function(character)\n    ...\nend)\n</code></pre> A ScriptSignal that fires when a player enters the Zone.</p>"},{"location":"api/Zone/#zoneplayerleft","title":"Zone.PlayerLeft","text":"<p><pre><code>Zone.PlayerLeft -- ScriptSignal\nlocal connection = Zone.PlayerLeft:Connect(function(character)\n    ...\nend)\n</code></pre> A ScriptSignal that fires when a player leaves the Zone.</p>"},{"location":"api/Zone/#zoneserial","title":"Zone.Serial","text":"<p><pre><code>Zone.Serial -- number\n</code></pre> A readonly number which stores the serial of the Zone. Note: Both Hitbox and Zone share the same serial incrementation.</p>"},{"location":"api/Zone/#zonecharacterresolution","title":"Zone.CharacterResolution","text":"<p><pre><code>Zone.CharacterResolution -- string\n</code></pre> What part(s) of a character must be present within the Zone in order for it to be fired in CharacterEntered, CharacterLeft, PlayerEntered and PlayerLeft. Can be <code>FullBody</code>, <code>Root</code>, <code>Head</code> or <code>OnePart</code>.</p>"},{"location":"api/Zone/#zonequerytype","title":"Zone.QueryType","text":"<p><pre><code>Zone.QueryType -- string\n</code></pre> Determines the type of spatial query. Can be <code>Full</code> or <code>Bounds</code>.</p>"},{"location":"api/Zone/#zonerate","title":"Zone.Rate","text":"<p><pre><code>Zone.Rate -- number\n</code></pre> How many times a second the Zone queries. Default 10.</p>"},{"location":"api/Zone/#zoneoverlapparams","title":"Zone.OverlapParams","text":"<p><pre><code>Zone.OverlapParams -- OverlapParams\n</code></pre> The <code>OverlapParams</code> used in spatial query.</p>"},{"location":"api/Zone/#zoneactive","title":"Zone.Active","text":"<p><pre><code>Zone.Active -- boolean\n</code></pre> A readonly boolean which indicates whether the Zone is activated or not. Note: You should use <code>Zone:Activate()</code> and <code>Zone:Deactivate()</code> instead.</p>"},{"location":"api/Zone/#zoneaddmemberbulkpartlist-basepart","title":"Zone:AddMemberBulk(partList: {BasePart})","text":"<p><pre><code>Zone:AddMemberBulk({part1, part2})\n</code></pre> Add a list of <code>BaseParts</code> into the Zone, automatically intiating their own ZoneComponents and Metafunctions.</p>"},{"location":"api/Zone/#zoneaddmemberpart-basepart-metafunctions-string-function","title":"Zone:AddMember(part: BasePart, Metafunctions: {string: function})","text":"<p><pre><code>Zone:AddMember(part, metafunctions)\n</code></pre> Add a <code>BasePart</code> into the Zone, automatically initiating a ZoneComponent for it. Metafunctions must be provided. Note: Use <code>Zone:TranslateToMetafunction(part)</code> to generate a basic Metafunction that you can use.</p>"},{"location":"api/Zone/#zonetranslatetometafunctionpart-basepart","title":"Zone:TranslateToMetafunction(part: BasePart)","text":"<p><pre><code>local metafunctions = Zone:TranslateToMetafunction(part) -&gt; {string: function}\n</code></pre> Generate a basic metafunction from <code>part</code>.</p>"},{"location":"api/Zone/#zoneremovememberpart-basepart","title":"Zone:RemoveMember(part: BasePart)","text":"<p><pre><code>Zone:RemoveMember(part)\n</code></pre> Remove <code>part</code> from the Zone if it exists, also removing all its associated ZoneComponents and Metafunctions.</p>"},{"location":"api/Zone/#zoneaddcomponentcomponent-zonecomponent","title":"Zone:AddComponent(component: ZoneComponent)","text":"<p><pre><code>local serial = Zone:AddComponent(component) -&gt; number or nil\n</code></pre> Add a <code>ZoneComponent</code> to the Zone directly, without the need for a <code>BasePart</code>. Returns the serial of the <code>ZoneComponent</code> if added successfully. Note: Methods dealing with ZoneComponents directly are for advanced use-cases. Do not use unless you know what you're doing.</p>"},{"location":"api/Zone/#zoneremovecomponentserial-number","title":"Zone:RemoveComponent(serial: number)","text":"<p><pre><code>Zone:RemoveComponent(index: BasePart or number)\n</code></pre> Remove <code>ZoneComponent</code> with <code>index</code> from the Zone. <code>ZoneComponent</code> generated from <code>Zone:AddMember()</code> and <code>Zone:AddMemberBulk()</code> have a BasePart index, while <code>ZoneComponent</code> generated from <code>Zone:AddComponent()</code> have a number index (same as its serial).</p>"},{"location":"api/Zone/#zoneupdate","title":"Zone:Update()","text":"<p><pre><code>Zone:Update()\n</code></pre> Manually trigger an update of the Zone. Note: You should call this if you change the Zone's properties or its ZoneComponents without using a built-in method.</p>"},{"location":"api/Zone/#zoneactivate","title":"Zone:Activate()","text":"<p><pre><code>Zone:Activate()\n</code></pre> Activates the Zone, resuming all spatial queries. Note: Zones are deactivated by default when created. You must call this method for the Zone to work.</p>"},{"location":"api/Zone/#zonedeactivate","title":"Zone:Deactivate()","text":"<p><pre><code>Zone:Deactivate()\n</code></pre> Deactivates the Zone, pausing all spatial queries.</p>"},{"location":"api/Zone/#zoneispartinsidepart-basepart","title":"Zone:IsPartInside(part: BasePart)","text":"<p><pre><code>local isInside = Zone:IsPartInside(part) -&gt; boolean\n</code></pre> Returns whether <code>part</code> is inside the Zone or not based on the Zone's query rules.</p>"},{"location":"api/Zone/#zoneischaracterinsidecharacter-model","title":"Zone:IsCharacterInside(character: Model)","text":"<p><pre><code>local isInside = Zone:IsCharacterInside(character) -&gt; boolean\n</code></pre> Returns whether <code>character</code> is inside the Zone or not based on the Zone's query rules.</p>"},{"location":"api/Zone/#zoneisplayerinsidecharacter-model","title":"Zone:IsPlayerInside(character: Model)","text":"<p><pre><code>local isInside = Zone:IsPlayerInside(character) -&gt; boolean\n</code></pre> Returns whether <code>character</code> is inside the Zone or not based on the Zone's query rules.</p>"},{"location":"api/Zone/#zonegetpartsinside","title":"Zone:GetPartsInside()","text":"<p><pre><code>local partList = Zone:GetPartsInside -&gt; {BasePart}\n</code></pre> Returns a list of all parts inside the Zone based on the Zone's query rules. Note: May or may not include member parts of the Zone.</p>"},{"location":"api/Zone/#zonegetcharactersinside","title":"Zone:GetCharactersInside()","text":"<p><pre><code>local characterList = Zone:GetCharactersInside() -&gt; {Model}\n</code></pre> Returns a list of characters inside the Zone based on the Zone's query rules.</p>"},{"location":"api/Zone/#zonegetplayersinside","title":"Zone:GetPlayersInside()","text":"<p><pre><code>local playerCharacterList = Zone:GetPlayersInside() -&gt; {Model}\n</code></pre> Returns a list of player characters inside the Zone based on the Zone's query rules.</p>"},{"location":"api/Zone/#zonedestroy","title":"Zone:Destroy()","text":"<p><pre><code>Zone:Destroy()\n</code></pre> Immediately clean and garbage collect the Zone, along with all its child ZoneComponents, ScriptSignals and Metafunctions. Note: The Zone should be dereferenced after calling this method.</p>"},{"location":"api/Zone/#private","title":"Private","text":""},{"location":"api/Zone/#zone_currentframe","title":"Zone._CurrentFrame","text":"<p><pre><code>Zone._CurrentFrame -- number\n</code></pre> An internal counter of the Zone's frame cycle. Note: This should be kept readonly.</p>"},{"location":"api/Zone/#zone_canwarn","title":"Zone._CanWarn","text":"<p><pre><code>Zone._CanWarn -- boolean\n</code></pre> An internal variable that acts as throttle to prevent console spam.</p>"},{"location":"api/Zone/#zone_visual","title":"Zone._Visual","text":"<p><pre><code>Zone._Visual -- BasePart or nil\n</code></pre> WARNING: This is STRICTLY readonly and internal. This should not be used under any circumstance.</p>"},{"location":"api/Zone/#zone_memberparts","title":"Zone._MemberParts","text":"<p><pre><code>Zone._MemberParts -- {BasePart}\n</code></pre> An internal store for the Zone's member parts.</p>"},{"location":"api/Zone/#zone_membercomponents","title":"Zone._MemberComponents","text":"<p><pre><code>Zone._MemberComponents -- {BasePart or number: ZoneComponent}\n</code></pre> An internal store for the Zone's ZoneComponents.</p>"},{"location":"api/Zone/#zone_partsinside","title":"Zone._PartsInside","text":"<p><pre><code>Zone._PartsInside -- {BasePart}\n</code></pre> An internal cache.</p>"},{"location":"api/Zone/#zone_charactersinside","title":"Zone._CharactersInside","text":"<p><pre><code>Zone._CharactersInside -- {Model}\n</code></pre> An internal cache.</p>"},{"location":"api/Zone/#zone_playersinside","title":"Zone._PlayersInside","text":"<p><pre><code>Zone._PlayersInside -- {Model}\n</code></pre> An internal cahce.</p>"},{"location":"api/Zone/#zone_destroying","title":"Zone._Destroying","text":"<p><pre><code>Zone._Destroying -- boolean\n</code></pre> An internal indicator indicating whether the Zone is being garbage collected or not. Note: The Zone should be dereferenced if this value is <code>true</code>.</p>"},{"location":"api/Zone/#zone_firstquery","title":"Zone._FirstQuery","text":"<p><pre><code>Zone._FirstQuery -- boolean\n</code></pre> An internal value. If <code>true</code>, the next query will not trigger <code>PartEntered</code>, <code>PartLeft</code>, <code>CharacterEntered</code>, <code>CharacterLeft</code>, <code>PlayerEntered</code> and <code>PlayerLeft</code>, then the value becomes <code>false</code>.</p> <p>The main enum and Metafunctions are intended to be completely private. You are not meant to access them.</p>"},{"location":"api/ZoneComponent/","title":"ZoneComponent","text":"<p>Child class of Zone. Represents a part in a Zone.</p>"},{"location":"api/ZoneComponent/#public","title":"Public","text":""},{"location":"api/ZoneComponent/#zonecomponentshape","title":"ZoneComponent.Shape","text":"<p><pre><code>ZoneComponent.Shape -- Enum.PartType\n</code></pre> The shape of the ZoneComponent.</p>"},{"location":"api/ZoneComponent/#zonecomponentcframe","title":"ZoneComponent.CFrame","text":"<p><pre><code>ZoneComponent.CFrame -- CFrame\n</code></pre> The CFrame of the ZoneComponent.</p>"},{"location":"api/ZoneComponent/#zonecomponentsize","title":"ZoneComponent.Size","text":"<p><pre><code>ZoneComponent.Size -- Vector3\n</code></pre> The Size of the ZoneComponent.</p>"},{"location":"api/ZoneComponent/#zonecomponentqueryquerytype-string-params-overlapparams","title":"ZoneComponent:Query(QueryType: string, Params: OverlapParams)","text":"<p><pre><code>local PartList = ZoneComponent:Query(\"Full\", OverlapParams) -&gt; {BasePart}\n</code></pre> QueryType can be <code>Full</code> or <code>Bounds</code>. Returns an array of <code>BasePart</code> inside the ZoneComponent.</p>"},{"location":"api/ZoneComponent/#zonecomponentgetcharacterscharacterresolution-string-querytype-string-params-overlapparams","title":"ZoneComponent:GetCharacters(CharacterResolution: string, QueryType: string, Params: OverlapParams)","text":"<p><pre><code>local CharacterList = ZoneComponent:GetCharacters(\"OnePart\", \"Bounds\", OverlapParams) -&gt; {Model}\n</code></pre> CharacterResolution can be <code>FullBody</code> or <code>Root</code> or <code>Head</code> or <code>OnePart</code>. QueryType can be <code>Full</code> or <code>Bounds</code>. Returns an array of Characters inside the ZoneComponent.</p>"},{"location":"api/ZoneComponent/#zonecomponentgetplayerscharacterresolution-string-querytype-string-params-overlapparams","title":"ZoneComponent:GetPlayers(CharacterResolution: string, QueryType: string, Params: OverlapParams)","text":"<p><pre><code>local PlayerCharacterList = ZoneComponent:GetPlayers(\"OnePart\", \"Bounds\", OverlapParams) -&gt; {Model}\n</code></pre> CharacterResolution can be <code>FullBody</code> or <code>Root</code> or <code>Head</code> or <code>OnePart</code>. QueryType can be <code>Full</code> or <code>Bounds</code>. Returns an array of PlayerCharacters inside the ZoneComponent.</p>"},{"location":"api/ZoneComponent/#zonecomponentdestroy","title":"ZoneComponent:Destroy()","text":"<p><pre><code>ZoneComponent:Destroy()\n</code></pre> Clean and garbage collect the ZoneComponent immediately. WARNING: Do NOT call when the ZoneComponent is a child of a Zone.</p>"},{"location":"api/ZoneComponent/#private","title":"Private","text":""},{"location":"api/ZoneComponent/#zonecomponent_part","title":"ZoneComponent._Part","text":"<p><pre><code>ZoneComponent._Part -- BasePart or nil\n</code></pre> An internal pointer. WARNING: STRICTLY readonly.</p>"},{"location":"api/ZoneComponent/#zonecomponent_state","title":"ZoneComponent._State","text":"<p><pre><code>ZoneComponent._State -- string\n</code></pre> The current state of the ZoneComponent. Can be <code>Active</code>, <code>Paused</code> or <code>Dead</code>. If the state is <code>Dead</code>, the ZoneComponent should not be referenced anymore.</p>"},{"location":"api/ZoneComponent/#zonecomponent_newpart","title":"ZoneComponent:_NewPart()","text":"<p><pre><code>ZoneComponent:_NewPart()\n</code></pre> An internal method. WARNING: Do NOT call under any circumstance.</p>"},{"location":"examples/HitboxExample/","title":"Hitbox","text":"<p>Simple melee weapon (server): <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal HitboxRemaster = require(modules:WaitForChild(\"HitboxRemaster\"))\nlocal Tool = script.Parent\nlocal Handle = Tool:WaitForChild(\"Handle\")\nlocal Debounce = true\n\nTool.Activated:Connect(function()\n    if Debounce == false then\n        return\n    end\n    Debounce = false\n    task.delay(1, function()\n        Debounce = true\n    end)\n    local Hitbox = HitboxRemaster.newHitbox({\n        [\"Pierce\"] = 3\n    })\n    Hitbox.CopyCFrame = Handle\n    Hitbox.Hit:Connect(function(Humanoid, HitPart, DataBundle)\n        if Hitbox:IsHitboxBackstab(HitPart, DataBundle) == true then\n            Humanoid:TakeDamage(20)\n        else\n            Humanoid:TakeDamage(10)\n        end\n    end)\nend)\n</code></pre> Note: Hitbox can also be used on client.</p>"},{"location":"examples/ZoneExample/","title":"Zone","text":"<p>Client-sided Zone example: <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal HitboxRemaster = require(modules:WaitForChild(\"HitboxRemaster\"))\nlocal QueryFunction = ReplicatedStorage:WaitForChild(\"QueryFunction\")\nlocal partList = workspace.ZoneTest:GetChildren() -- All members of partList MUST be BasePart!\n\nlocal Zone = HitboxRemaster.newZone({\n    [\"CharacterResolution\"] = \"OnePart\",\n    [\"QueryType\"] = \"Full\"\n})\nZone:AddMemberBulk(partList)\n\nZone.PartEntered:Connect(function(part)\n    print(\"Part entered! \" .. part.Name)\n    end)\n\nZone.PartLeft:Connect(function(part)\n    print(\"Part left! \" .. part.Name)\nend)\n\nZone.CharacterEntered:Connect(function(char)\n    print(\"Character entered! \" .. char.Name)\nend)\n\nZone.CharacterLeft:Connect(function(char)\n    print(\"Character left! \" .. char.Name)\nend)\n\nZone.PlayerEntered:Connect(function(char)\n    print(\"Player entered! \" .. char.Name)\nend)\n\nZone.PlayerLeft:Connect(function(char)\n    print(\"Player left! \" .. char.Name)\nend)\n\nZone:Activate()\n\nQueryEvent.OnClientInvoke = function()\n    return Zone:GetCharactersInside()\nend\n</code></pre> Note: Zone can be used the same way in both server and client.</p>"}]}